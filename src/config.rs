use serde::Deserialize;
use std::fs;
use std::path::{Path, PathBuf};

use crate::util::{expand_tilde, home_dir};

#[derive(Debug, Deserialize, Clone, Default)]
pub struct TestCfg {
    #[serde(default = "default_tests_path")]
    pub tests_path: String,
    #[serde(default = "default_digital_path")]
    pub digital_path: String,
}

fn default_tests_path() -> String { String::from("~/tests") }
fn default_digital_path() -> String { String::from("~/Digital/Digital.jar") }

#[derive(Debug, Deserialize, Clone, Default)]
pub struct ConfigCfg {
    #[serde(default)]
    pub students: Vec<String>,
}

#[derive(Debug, Deserialize, Clone, Default)]
pub struct GitCfg {
    #[serde(default)]
    pub org: String,
    #[serde(default = "default_credentials")]
    pub credentials: String,
}
fn default_credentials() -> String { String::from("ssh") }

#[derive(Debug, Deserialize, Clone, Default)]
pub struct GithubCfg {
    #[serde(default = "default_github_host")] pub host_name: String,
    #[serde(default)] pub access_token: String,
}
fn default_github_host() -> String { String::from("api.github.com") }

#[derive(Debug, Deserialize, Clone, Default)]
pub struct CanvasCfg {
    #[serde(default)] pub host_name: String,
    #[serde(default)] pub access_token: String,
    #[serde(default)] pub course_name: String,
}

#[derive(Debug, Deserialize, Clone, Default)]
pub struct CanvasMapperCfg {
    #[serde(default)] pub map_path: String,
    #[serde(default = "default_github_col")] pub github_col_name: String,
    #[serde(default = "default_login_col")] pub login_col_name: String,
}
fn default_github_col() -> String { String::from("GitHub") }
fn default_login_col() -> String { String::from("SIS Login ID") }

#[derive(Debug, Deserialize, Clone, Default)]
pub struct Config {
    #[allow(non_snake_case)]
    #[serde(default)]
    pub Test: Option<TestCfg>,
    #[allow(non_snake_case)]
    #[serde(default)]
    pub Config: Option<ConfigCfg>,
    #[allow(non_snake_case)]
    #[serde(default)]
    pub Git: Option<GitCfg>,
    #[allow(non_snake_case)]
    #[serde(default)]
    pub Github: Option<GithubCfg>,
    #[allow(non_snake_case)]
    #[serde(default)]
    pub Canvas: Option<CanvasCfg>,
    #[allow(non_snake_case)]
    #[serde(default)]
    pub CanvasMapper: Option<CanvasMapperCfg>,

    // Flattened public view for convenience
    #[serde(skip)]
    pub test: TestCfg,
    #[serde(skip)]
    pub config: ConfigCfg,
    #[serde(skip)]
    pub git: GitCfg,
    #[serde(skip)]
    pub github: GithubCfg,
    #[serde(skip)]
    pub canvas: CanvasCfg,
    #[serde(skip)]
    pub canvas_mapper: CanvasMapperCfg,
}

impl Config {
    pub fn load_or_create(path: &Path) -> anyhow::Result<Self> {
        if !path.exists() {
            if let Some(parent) = path.parent() { fs::create_dir_all(parent)?; }
            fs::write(path, Self::default_toml())?;
            println!("Created config file: {}", path.display());
        }
        let content = fs::read_to_string(path)?;
        let mut raw: Config = toml::from_str(&content).unwrap_or_default();
        raw.test = raw.Test.clone().unwrap_or_default();
        raw.config = raw.Config.clone().unwrap_or_default();
        raw.git = raw.Git.clone().unwrap_or_default();
        raw.github = raw.Github.clone().unwrap_or_default();
        raw.canvas = raw.Canvas.clone().unwrap_or_default();
        raw.canvas_mapper = raw.CanvasMapper.clone().unwrap_or_default();
        Ok(raw)
    }

    fn default_toml() -> String {
        let s = r#"# Autogenerated defaults. Uncomment and edit as needed.

[Canvas]
# host_name = "canvas.instructure.com"
# access_token = "your access token here"
# course_name = "Your long course name"

[CanvasMapper]
# map_path = "~/github-to-canvas.csv"
# github_col_name = "GitHub"
# login_col_name = "SIS Login ID"

[Config]
# students = []

[Git]
# org = "your-org"
# credentials = "ssh" # or "https"

[Github]
# host_name = "api.github.com"
# access_token = "token"

[Test]
# tests_path = "~/tests"
# digital_path = "~/Digital/Digital.jar"
"#;
        s.to_string()
    }
}

pub fn resolve_config_path() -> PathBuf {
    let fname = "config.toml";
    if let Ok(dir) = std::env::var("GRADE_CONFIG_DIR") {
        return Path::new(&expand_tilde(&dir)).join(fname);
    }
    // walk upward until $HOME
    let mut dir = std::env::current_dir().unwrap_or_else(|_| PathBuf::from("."));
    let home = home_dir();
    loop {
        let p = dir.join(fname);
        if p.exists() { return p; }
        if dir == home { break; }
        if !dir.pop() { break; }
    }
    Path::new(&home).join(".config").join("grade").join(fname)
}
